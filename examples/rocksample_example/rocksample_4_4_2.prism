pomdp

observables
started, r1taken, r1lastobs , r2taken, r2lastobs, done
endobservables

// Map visualization


const int N = 4;
const int xMAX = N-1;
const int yMAX = N-1;
const int xMIN = 0;
const int yMIN = 0;
const double slippery = 0.1;

// Rock positions
const r1x = xMIN+1;
const r1y = yMAX-1;
const r2x = 1;
const r2y = floor(yMAX/2);

// How likely is a rock a good rock
const double goodrock = 0.5;

// We are done when we reach max x location
formula finish = started & x = xMAX;
formula good = finish & !done & ((!r1qual & !r2qual ) | (r1taken | r2taken ));

// Observe when reaching the exit
observable "seefinish" = finish;

// Distance between r1 and the robot
formula r1dist = max(r1x-x,x-r1x) + max(r1y-y,y-r1y);

// max distance
formula maxdist = xMAX-xMIN+yMAX-yMIN;

// Distance between r1 and the robot
formula r2dist = max(r2x-x,x-r2x) + max(r2y-y,y-r2y);
formula bad = (r1dist=0 & !r1qual) | (r2dist=0 & !r2qual);

// Observe the bad or good rock
observable "seebad" = bad;
observable "seegood" = good;

// Observe when the distance to a rock is zero and where at 1 cell away from a rock
observable "atr1" = r1dist <= 0;
observable "atr2" = r2dist <= 0;
// observable "nearr1" = r1dist <= 1;
// observable "nearr2" = r2dist <= 1;

// Compute distance to the rocks
formula normdistr1 = (r1dist <= 1) ? 1 : 2; 
// formula normdistr1 = 1/(1 - 0.7*(r1dist/maxdist));
formula normdistr2 = (r2dist <= 1) ? 1 : 2; 
// formula normdistr2 = 1/(1 - 0.7*(r2dist/maxdist));

module master
    started : bool init false;
    done : bool init false;

    [placement] !started -> (started'=true);
    [north] started & !done -> true;
    [south] started  & !done -> true;
    [east] started  & !done-> true;
    [west] started & !done -> true;
    [finish] finish -> (done'=true);
endmodule

module rock1
    r1qual : bool init false;
    r1taken : bool init false;
    r1lastobs : bool init false;
    [placement] !started -> goodrock : (r1qual'=true) + (1-goodrock) : (r1qual'=false);

    [r1sample] r1dist = 0 & started & !done & !bad & !finish -> 1:(r1taken'=(x = r1x & y = r1y & !r1taken));
    [r1sense] started & !r1taken & !done & !bad & !finish -> (1/normdistr1): (r1lastobs'=r1qual) +  (1-(1/normdistr1)): (r1lastobs'=!r1qual);
    [north] !done -> (r1lastobs'=false);
    [south] !done -> (r1lastobs'=false);
    [east] !done -> (r1lastobs'=false);
    [west] !done -> (r1lastobs'=false);
endmodule

module rock2 = rock1[r1sample=r2sample, r1sense=r2sense, r1x = r2x, r1y = r2y, r1qual=r2qual,r1taken=r2taken,r1lastobs=r2lastobs,r1dist=r2dist,normdistr1=normdistr2] endmodule

module robot
    x : [xMIN..xMAX] init 0;
    y : [yMIN..yMAX] init 0;

    [placement] !started ->     1/12 : (x'=0) & (y'=0)
                            +   1/12 : (x'=0) & (y'=1) 
                            +   1/12 : (x'=0) & (y'=2)
                            +   1/12 : (x'=0) & (y'=3) 
                            +   1/12 : (x'=1) & (y'=0)
                            +   1/12 : (x'=1) & (y'=1) 
                            +   1/12 : (x'=1) & (y'=2)
                            +   1/12 : (x'=1) & (y'=3) 
                            +   1/12 : (x'=2) & (y'=0)
                            +   1/12 : (x'=2) & (y'=1) 
                            +   1/12 : (x'=2) & (y'=2)
                            +   1/12 : (x'=2) & (y'=3);
    [west] started & !done -> (1-slippery): (x'=max(x-1,xMIN)) + slippery: (x'=max(x-2,xMIN));
    [east] started & !done -> (1-slippery): (x'=min(x+1,xMAX)) + slippery: (x'=min(x+2,xMAX));
    [south]  started & !done -> (1-slippery): (y'=min(y+1,yMAX)) + slippery: (y'=min(y+2,yMAX));
    [north]  started & !done -> (1-slippery): (y'=max(y-1,yMIN)) + slippery: (y'=max(y-2,yMIN));
endmodule

// First reward feature -> Time spent picking an action
rewards "total_time"
    [west] true : -1;
    [east] true : -1;
    [north] true : -1;
    [south] true : -1;
    // [r1sense] true : -1;
    // [r2sense] true : -1;
    // [r1sample] true : -2;
    // [r2sample] true : -2;
    // [placement] true : -1;
endrewards

// Second reward feature -> Cost of sensing/sampling
rewards "sense_time"
    [r1sample] true : -2;
    [r2sample] true : -2;
    [r1sense] true : -1;
    [r2sense] true : -1;
endrewards

// Third reward feature -> Reaching the finish with good rocks
rewards "finish_grock"
    [finish] good : 1;
endrewards

// Fourth reward feature -> Reaching the finish
// rewards "finish"
//    [finish] finish & !done : 1;
// endrewards


// Third reward feature ->  Penalize going to bad rocks
// rewards "bad_rock"
//    [west] bad : -1;
//    [east] bad : -1;
//    [north] bad : -1;
//    [south] bad : -1;
//    [r1sample] bad : -1;
//    [r2sample] bad : -1;
//    [r1sense] bad : -1;
//    [r2sense] bad : -1;
// endrewards


label "notr1done" = !r1taken;
label "r2done" = ((r2dist=0 & !r2qual) | r2taken);

label "goal" = finish & done & ((!r1qual & !r2qual ) | (r1taken | r2taken ));
// label "rockposition" = (!r1taken & r1x = x & r1y = y) | (!r2taken & r2x = x & r2y = y);
// label "notbad" = !bad;